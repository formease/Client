(() => { const m = class {constructor () { this.reject = () => {}, this.resolve = () => {}, this.promise = new Promise((e, t) => { this.resolve = e, this.reject = t }) }wrapCallback (e) { return (t, n) => { t ? this.reject(t) : this.resolve(n), typeof e === 'function' && (this.promise.catch(() => {}), e.length === 1 ? e(t) : e(t, n)) } }}; const T = 'FirebaseError'; var l = class extends Error {constructor (e, t, n) { super(t); this.code = e, this.customData = n, this.name = T, Object.setPrototypeOf(this, l.prototype), Error.captureStackTrace && Error.captureStackTrace(this, d.prototype.create) }}; var d = class {constructor (e, t, n) { this.service = e, this.serviceName = t, this.errors = n }create (e, ...t) { const n = t[0] || {}; const r = `${this.service}/${e}`; const s = this.errors[e]; const a = s ? x(s, n) : 'Error'; const c = `${this.serviceName}: ${a} (${r}).`; return new l(r, c, n) }}; function x (i, e) { return i.replace(R, (t, n) => { const r = e[n]; return r != null ? String(r) : `<${n}?>` }) } var R = /\{\$([^}]+)}/g; function p (i, e) { if (i === e) return !0; const t = Object.keys(i); const n = Object.keys(e); for (const r of t) { if (!n.includes(r)) return !1; const s = i[r]; const a = e[r]; if (w(s) && w(a)) { if (!p(s, a)) return !1 } else if (s !== a) return !1 } for (const r of n) if (!t.includes(r)) return !1; return !0 } function w (i) { return i !== null && typeof i === 'object' } const Ee = 4 * 60 * 60 * 1e3; const h = class {constructor (e, t, n) { this.name = e, this.instanceFactory = t, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = 'LAZY', this.onInstanceCreated = null }setInstantiationMode (e) { return this.instantiationMode = e, this }setMultipleInstances (e) { return this.multipleInstances = e, this }setServiceProps (e) { return this.serviceProps = e, this }setInstanceCreatedCallback (e) { return this.onInstanceCreated = e, this }}; const f = '[DEFAULT]'; const O = class {constructor (e, t) { this.name = e, this.container = t, this.component = null, this.instances = new Map(), this.instancesDeferred = new Map(), this.instancesOptions = new Map(), this.onInitCallbacks = new Map() }get (e) { const t = this.normalizeInstanceIdentifier(e); if (!this.instancesDeferred.has(t)) { const n = new m(); if (this.instancesDeferred.set(t, n), this.isInitialized(t) || this.shouldAutoInitialize()) try { const r = this.getOrInitializeService({ instanceIdentifier: t }); r && n.resolve(r) } catch {} } return this.instancesDeferred.get(t).promise }getImmediate (e) { let t; const n = this.normalizeInstanceIdentifier(e == null ? void 0 : e.identifier); const r = (t = e == null ? void 0 : e.optional) !== null && t !== void 0 ? t : !1; if (this.isInitialized(n) || this.shouldAutoInitialize()) try { return this.getOrInitializeService({ instanceIdentifier: n }) } catch (s) { if (r) return null; throw s } else { if (r) return null; throw Error(`Service ${this.name} is not available`) } }getComponent () { return this.component }setComponent (e) { if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`); if (this.component) throw Error(`Component for ${this.name} has already been provided`); if (this.component = e, !!this.shouldAutoInitialize()) { if (B(e)) try { this.getOrInitializeService({ instanceIdentifier: f }) } catch {} for (const [t, n] of this.instancesDeferred.entries()) { const r = this.normalizeInstanceIdentifier(t); try { const s = this.getOrInitializeService({ instanceIdentifier: r }); n.resolve(s) } catch {} } } }clearInstance (e = f) { this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e) } async delete () { const e = Array.from(this.instances.values()); await Promise.all([...e.filter(t => 'INTERNAL' in t).map(t => t.INTERNAL.delete()), ...e.filter(t => '_delete' in t).map(t => t._delete())]) }isComponentSet () { return this.component != null }isInitialized (e = f) { return this.instances.has(e) }getOptions (e = f) { return this.instancesOptions.get(e) || {} }initialize (e = {}) { const { options: t = {} } = e; const n = this.normalizeInstanceIdentifier(e.instanceIdentifier); if (this.isInitialized(n)) throw Error(`${this.name}(${n}) has already been initialized`); if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`); const r = this.getOrInitializeService({ instanceIdentifier: n, options: t }); for (const [s, a] of this.instancesDeferred.entries()) { const c = this.normalizeInstanceIdentifier(s); n === c && a.resolve(r) } return r }onInit (e, t) { let n; const r = this.normalizeInstanceIdentifier(t); const s = (n = this.onInitCallbacks.get(r)) !== null && n !== void 0 ? n : new Set(); s.add(e), this.onInitCallbacks.set(r, s); const a = this.instances.get(r); return a && e(a, r), () => { s.delete(e) } }invokeOnInitCallbacks (e, t) { const n = this.onInitCallbacks.get(t); if (n) for (const r of n) try { r(e, t) } catch {} }getOrInitializeService ({ instanceIdentifier: e, options: t = {} }) { let n = this.instances.get(e); if (!n && this.component && (n = this.component.instanceFactory(this.container, { instanceIdentifier: L(e), options: t }), this.instances.set(e, n), this.instancesOptions.set(e, t), this.invokeOnInitCallbacks(n, e), this.component.onInstanceCreated)) try { this.component.onInstanceCreated(this.container, e, n) } catch {} return n || null }normalizeInstanceIdentifier (e = f) { return this.component ? this.component.multipleInstances ? e : f : e }shouldAutoInitialize () { return !!this.component && this.component.instantiationMode !== 'EXPLICIT' }}; function L (i) { return i === f ? void 0 : i } function B (i) { return i.instantiationMode === 'EAGER' } const g = class {constructor (e) { this.name = e, this.providers = new Map() }addComponent (e) { const t = this.getProvider(e.name); if (t.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`); t.setComponent(e) }addOrOverwriteComponent (e) { this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e) }getProvider (e) { if (this.providers.has(e)) return this.providers.get(e); const t = new O(e, this); return this.providers.set(e, t), t }getProviders () { return Array.from(this.providers.values()) }}; const M = []; let o; (function (i) { i[i.DEBUG = 0] = 'DEBUG', i[i.VERBOSE = 1] = 'VERBOSE', i[i.INFO = 2] = 'INFO', i[i.WARN = 3] = 'WARN', i[i.ERROR = 4] = 'ERROR', i[i.SILENT = 5] = 'SILENT' })(o || (o = {})); const $ = { debug: o.DEBUG, verbose: o.VERBOSE, info: o.INFO, warn: o.WARN, error: o.ERROR, silent: o.SILENT }; const k = o.INFO; const P = { [o.DEBUG]: 'log', [o.VERBOSE]: 'log', [o.INFO]: 'info', [o.WARN]: 'warn', [o.ERROR]: 'error' }; const z = (i, e, ...t) => { if (e < i.logLevel) return; const n = new Date().toISOString(); const r = P[e]; if (r)console[r](`[${n}]  ${i.name}:`, ...t); else throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`) }; const b = class {constructor (e) { this.name = e, this._logLevel = k, this._logHandler = z, this._userLogHandler = null, M.push(this) } get logLevel () { return this._logLevel } set logLevel (e) { if (!(e in o)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``); this._logLevel = e }setLogLevel (e) { this._logLevel = typeof e === 'string' ? $[e] : e } get logHandler () { return this._logHandler } set logHandler (e) { if (typeof e !== 'function') throw new TypeError('Value assigned to `logHandler` must be a function'); this._logHandler = e } get userLogHandler () { return this._userLogHandler } set userLogHandler (e) { this._userLogHandler = e }debug (...e) { this._userLogHandler && this._userLogHandler(this, o.DEBUG, ...e), this._logHandler(this, o.DEBUG, ...e) }log (...e) { this._userLogHandler && this._userLogHandler(this, o.VERBOSE, ...e), this._logHandler(this, o.VERBOSE, ...e) }info (...e) { this._userLogHandler && this._userLogHandler(this, o.INFO, ...e), this._logHandler(this, o.INFO, ...e) }warn (...e) { this._userLogHandler && this._userLogHandler(this, o.WARN, ...e), this._logHandler(this, o.WARN, ...e) }error (...e) { this._userLogHandler && this._userLogHandler(this, o.ERROR, ...e), this._logHandler(this, o.ERROR, ...e) }}; const S = class {constructor (e) { this.container = e }getPlatformInfoString () { return this.container.getProviders().map(t => { if (j(t)) { const n = t.getImmediate(); return `${n.library}/${n.version}` } else return null }).filter(t => t).join(' ') }}; function j (i) { const e = i.getComponent(); return (e == null ? void 0 : e.type) === 'VERSION' } const _ = '@firebase/app'; const I = '0.7.16'; const A = new b('@firebase/app'); const F = '@firebase/app-compat'; const V = '@firebase/analytics-compat'; const H = '@firebase/analytics'; const U = '@firebase/app-check-compat'; const W = '@firebase/app-check'; const G = '@firebase/auth'; const K = '@firebase/auth-compat'; const J = '@firebase/database'; const q = '@firebase/database-compat'; const Y = '@firebase/functions'; const X = '@firebase/functions-compat'; const Q = '@firebase/installations'; const Z = '@firebase/installations-compat'; const ee = '@firebase/messaging'; const te = '@firebase/messaging-compat'; const ne = '@firebase/performance'; const ie = '@firebase/performance-compat'; const re = '@firebase/remote-config'; const se = '@firebase/remote-config-compat'; const oe = '@firebase/storage'; const ae = '@firebase/storage-compat'; const ce = '@firebase/firestore'; const fe = '@firebase/firestore-compat'; const le = 'firebase'; const he = '[DEFAULT]'; const ue = { [_]: 'fire-core', [F]: 'fire-core-compat', [H]: 'fire-analytics', [V]: 'fire-analytics-compat', [W]: 'fire-app-check', [U]: 'fire-app-check-compat', [G]: 'fire-auth', [K]: 'fire-auth-compat', [J]: 'fire-rtdb', [q]: 'fire-rtdb-compat', [Y]: 'fire-fn', [X]: 'fire-fn-compat', [Q]: 'fire-iid', [Z]: 'fire-iid-compat', [ee]: 'fire-fcm', [te]: 'fire-fcm-compat', [ne]: 'fire-perf', [ie]: 'fire-perf-compat', [re]: 'fire-rc', [se]: 'fire-rc-compat', [oe]: 'fire-gcs', [ae]: 'fire-gcs-compat', [ce]: 'fire-fst', [fe]: 'fire-fst-compat', 'fire-js': 'fire-js', [le]: 'fire-js-all' }; const y = new Map(); const E = new Map(); function de (i, e) { try { i.container.addComponent(e) } catch (t) { A.debug(`Component ${e.name} failed to register with FirebaseApp ${i.name}`, t) } } function C (i) { const e = i.name; if (E.has(e)) return A.debug(`There were multiple attempts to register component ${e}.`), !1; E.set(e, i); for (const t of y.values())de(t, i); return !0 } const pe = { 'no-app': "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()", 'bad-app-name': "Illegal App name: '{$appName}", 'duplicate-app': "Firebase App named '{$appName}' already exists with different options or config", 'app-deleted': "Firebase App named '{$appName}' already deleted", 'invalid-app-argument': 'firebase.{$appName}() takes either no argument or a Firebase App instance.', 'invalid-log-argument': 'First argument to `onLog` must be null or a function.' }; const v = new d('app', 'Firebase', pe); const D = class {constructor (e, t, n) { this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, t), this._name = t.name, this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled, this._container = n, this.container.addComponent(new h('app', () => this, 'PUBLIC')) } get automaticDataCollectionEnabled () { return this.checkDestroyed(), this._automaticDataCollectionEnabled } set automaticDataCollectionEnabled (e) { this.checkDestroyed(), this._automaticDataCollectionEnabled = e } get name () { return this.checkDestroyed(), this._name } get options () { return this.checkDestroyed(), this._options } get config () { return this.checkDestroyed(), this._config } get container () { return this._container } get isDeleted () { return this._isDeleted } set isDeleted (e) { this._isDeleted = e }checkDestroyed () { if (this.isDeleted) throw v.create('app-deleted', { appName: this._name }) }}; function N (i, e = {}) { typeof e !== 'object' && (e = { name: e }); const t = Object.assign({ name: he, automaticDataCollectionEnabled: !1 }, e); const n = t.name; if (typeof n !== 'string' || !n) throw v.create('bad-app-name', { appName: String(n) }); const r = y.get(n); if (r) { if (p(i, r.options) && p(t, r.config)) return r; throw v.create('duplicate-app', { appName: n }) } const s = new g(n); for (const c of E.values())s.addComponent(c); const a = new D(i, t, s); return y.set(n, a), a } function u (i, e, t) { let n; let r = (n = ue[i]) !== null && n !== void 0 ? n : i; t && (r += `-${t}`); const s = r.match(/\s|\//); const a = e.match(/\s|\//); if (s || a) { const c = [`Unable to register library "${r}" with version "${e}":`]; s && c.push(`library name "${r}" contains illegal characters (whitespace or "/")`), s && a && c.push('and'), a && c.push(`version name "${e}" contains illegal characters (whitespace or "/")`), A.warn(c.join(' ')); return }C(new h(`${r}-version`, () => ({ library: r, version: e }), 'VERSION')) } function me (i) { C(new h('platform-logger', e => new S(e), 'PRIVATE')), u(_, I, i), u(_, I, 'esm2017'), u('fire-js', '') }me(''); const ge = 'firebase'; const be = '9.6.6'; u(ge, be, 'app'); function _e () { return new Promise((i, e) => { const n = N({ apiKey: 'AIzaSyCtLctmVtf5LgHJv2y4h5eVx3h6DsM4KRY', authDomain: 'forms-server.firebaseapp.com', projectId: 'forms-server', storageBucket: 'forms-server.appspot.com', messagingSenderId: '265562888456', appId: '1:265562888456:web:0ad6cfe8a44ef7af7234bd' }); i() }) }(async () => (await _e(), console.log('Firebase initialized')))() })()
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
